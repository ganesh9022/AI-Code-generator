{
    "addition": "const addition = (a, b) => a + b;",
    "subtraction": "const subtraction = (a, b) => a - b;",
    "multiplication": "const multiplication = (a, b) => a * b;",
    "division": "const division = (a, b) => a / b;",
    "factorial": "const factorial = n => n <= 0 ? 1 : n * factorial(n - 1);",
    "square": "const square = x => x * x;",
    "squareRoot": "const squareRoot = x => Math.sqrt(x);",
    "power": "const power = (x, y) => Math.pow(x, y);",
    "modulus": "const modulus = (a, b) => a % b;",
    "absolute": "const absolute = x => Math.abs(x);",
    "maximum": "const maximum = (a, b) => Math.max(a, b);",
    "minimum": "const minimum = (a, b) => Math.min(a, b);",
    "average": "const average = arr => arr.reduce((a, b) => a + b, 0) / arr.length;",
    "sum": "const sum = arr => arr.reduce((a, b) => a + b, 0);",
    "sortAscending": "const sortAscending = arr => arr.sort((a, b) => a - b);",
    "sortDescending": "const sortDescending = arr => arr.sort((a, b) => b - a);",
    "reverseString": "const reverseString = str => str.split('').reverse().join('');",
    "capitalize": "const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);",
    "isPalindrome": "const isPalindrome = str => str === str.split('').reverse().join('');",
    "fibonacci": "const fibonacci = n => n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);",
    "gcd": "const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);",
    "lcm": "const lcm = (a, b) => (a * b) / gcd(a, b);",
    "factorize": "const factorize = n => Array.from({ length: n }, (_, i) => i + 1).filter(i => n % i === 0);",
    "isPrime": "const isPrime = n => n > 1 && Array.from({ length: Math.sqrt(n) }, (_, i) => i + 2).every(i => n % i !== 0);",
    "binarySearch": "const binarySearch = (arr, x) => {\n\tlet l = 0, h = arr.length - 1;\n\twhile (l <= h) {\n\t\tconst m = Math.floor((l + h) / 2);\n\t\tif (arr[m] === x) return m;\n\t\telse if (arr[m] < x) l = m + 1;\n\t\telse h = m - 1;\n\t}\n\treturn -1;\n};",
    "mergeSort": "const mergeSort = arr => {\n\tif (arr.length < 2) return arr;\n\tconst mid = Math.floor(arr.length / 2);\n\tconst left = mergeSort(arr.slice(0, mid));\n\tconst right = mergeSort(arr.slice(mid));\n\treturn merge(left, right);\n};",
    "quickSort": "const quickSort = arr => {\n\tif (arr.length < 2) return arr;\n\tconst pivot = arr[0];\n\tconst lesser = arr.slice(1).filter(el => el < pivot);\n\tconst greater = arr.slice(1).filter(el => el >= pivot);\n\treturn [...quickSort(lesser), pivot, ...quickSort(greater)];\n};",
    "merge": "const merge = (left, right) => {\n\tconst result = [];\n\tlet li = 0, ri = 0;\n\twhile (li < left.length && ri < right.length) {\n\t\tif (left[li] < right[ri]) result.push(left[li++]);\n\t\telse result.push(right[ri++]);\n\t}\n\treturn [...result, ...left.slice(li), ...right.slice(ri)];\n};",
    "linearSearch": "const linearSearch = (arr, x) => {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] === x) return i;\n\t}\n\treturn -1;\n};",
    "bubbleSort": "const bubbleSort = arr => {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tfor (let j = 0; j < arr.length - i - 1; j++) {\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\tconst temp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\treturn arr;\n};",
    "factorialIterative": "const factorialIterative = n => {\n\tlet result = 1;\n\tfor (let i = 1; i <= n; i++) {\n\t\tresult *= i;\n\t}\n\treturn result;\n};",
    "nthRoot": "const nthRoot = (x, n) => Math.pow(x, 1 / n);",
    "logarithm": "const logarithm = (x, base = 10) => Math.log(x) / Math.log(base);",
    "exponential": "const exponential = x => Math.exp(x);",
    "sin": "const sin = x => Math.sin(x);",
    "cos": "const cos = x => Math.cos(x);",
    "tan": "const tan = x => Math.tan(x);",
    "asin": "const asin = x => Math.asin(x);",
    "acos": "const acos = x => Math.acos(x);",
    "atan": "const atan = x => Math.atan(x);",
    "randomInt": "const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;",
    "shuffleArray": "const shuffleArray = arr => {\n\tfor (let i = arr.length - 1; i > 0; i--) {\n\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t[arr[i], arr[j]] = [arr[j], arr[i]];\n\t}\n\treturn arr;\n};",
    "debounce": "const debounce = (func, delay) => {\n\tlet timerId;\n\treturn function(...args) {\n\t\tclearTimeout(timerId);\n\t\ttimerId = setTimeout(() => func.apply(this, args), delay);\n\t};\n};",
    "throttle": "const throttle = (func, limit) => {\n\tlet lastFunc;\n\tlet lastRan;\n\treturn function(...args) {\n\t\tconst context = this;\n\t\tif (!lastRan) {\n\t\t\tfunc.apply(context, args);\n\t\t\tlastRan = Date.now();\n\t\t} else {\n\t\t\tclearTimeout(lastFunc);\n\t\t\tlastFunc = setTimeout(() => {\n\t\t\t\tif ((Date.now() - lastRan) >= limit) {\n\t\t\t\t\tfunc.apply(context, args);\n\t\t\t\t\tlastRan = Date.now();\n\t\t\t\t}\n\t\t\t}, limit - (Date.now() - lastRan));\n\t\t}\n\t};\n};",
    "cloneDeep": "const cloneDeep = obj => JSON.parse(JSON.stringify(obj));",
    "deepEqual": "const deepEqual = (a, b) => {\n\tif (a === b) return true;\n\tif (typeof a === 'object' && typeof b === 'object' && a != null && b != null) {\n\t\tconst keysA = Object.keys(a);\n\t\tconst keysB = Object.keys(b);\n\t\tif (keysA.length !== keysB.length) return false;\n\t\tfor (const key of keysA) {\n\t\t\tif (!keysB.includes(key) || !deepEqual(a[key], b[key])) return false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n};",
    "flattenArray": "const flattenArray = arr => arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flattenArray(toFlatten) : toFlatten), []);",
    "uniqueElements": "const uniqueElements = arr => [...new Set(arr)];",
    "intersection": "const intersection = (arr1, arr2) => arr1.filter(x => arr2.includes(x));"
}

{
    "addition": "const addition = (a: number, b: number): number => a + b;",
    "subtraction": "const subtraction = (a: number, b: number): number => a - b;",
    "multiplication": "const multiplication = (a: number, b: number): number => a * b;",
    "division": "const division = (a: number, b: number): number => a / b;",
    "factorial": "const factorial = (n: number): number => n <= 0 ? 1 : n * factorial(n - 1);",
    "square": "const square = (x: number): number => x * x;",
    "squareRoot": "const squareRoot = (x: number): number => Math.sqrt(x);",
    "power": "const power = (x: number, y: number): number => Math.pow(x, y);",
    "modulus": "const modulus = (a: number, b: number): number => a % b;",
    "absolute": "const absolute = (x: number): number => Math.abs(x);",
    "maximum": "const maximum = (a: number, b: number): number => Math.max(a, b);",
    "minimum": "const minimum = (a: number, b: number): number => Math.min(a, b);",
    "average": "const average = (arr: number[]): number => arr.reduce((sum, value) => sum + value, 0) / arr.length;",
    "sum": "const sum = (arr: number[]): number => arr.reduce((sum, value) => sum + value, 0);",
    "sortAscending": "const sortAscending = (arr: number[]): number[] => arr.sort((a, b) => a - b);",
    "sortDescending": "const sortDescending = (arr: number[]): number[] => arr.sort((a, b) => b - a);",
    "reverseString": "const reverseString = (str: string): string => str.split('').reverse().join('');",
    "capitalize": "const capitalize = (str: string): string => str.charAt(0).toUpperCase() + str.slice(1);",
    "isPalindrome": "const isPalindrome = (str: string): boolean => str === reverseString(str);",
    "fibonacci": "const fibonacci = (n: number): number => n <= 1 ? n : fibonacci(n - 1) + fibonacci(n - 2);",
    "gcd": "const gcd = (a: number, b: number): number => b === 0 ? a : gcd(b, a % b);",
    "lcm": "const lcm = (a: number, b: number): number => (a * b) / gcd(a, b);",
    "factorize": "const factorize = (n: number): number[] => { let factors: number[] = []; for (let i = 1; i <= n; i++) { if (n % i === 0) factors.push(i); } return factors; };",
    "isPrime": "const isPrime = (n: number): boolean => { if (n <= 1) return false; for (let i = 2; i <= Math.sqrt(n); i++) { if (n % i === 0) return false; } return true; };",
    "binarySearch": "const binarySearch = (arr: number[], x: number): number => { let l = 0, h = arr.length - 1; while (l <= h) { let m = Math.floor((l + h) / 2); if (arr[m] === x) return m; if (arr[m] < x) l = m + 1; else h = m - 1; } return -1; };",
    "mergeSort": "const mergeSort = (arr: number[]): number[] => { if (arr.length < 2) return arr; let mid = Math.floor(arr.length / 2); let left = mergeSort(arr.slice(0, mid)); let right = mergeSort(arr.slice(mid)); return merge(left, right); };",
    "quickSort": "const quickSort = (arr: number[]): number[] => { if (arr.length < 2) return arr; let pivot = arr[0]; let lesser = arr.slice(1).filter(el => el < pivot); let greater = arr.slice(1).filter(el => el >= pivot); return [...quickSort(lesser), pivot, ...quickSort(greater)]; };",
    "merge": "const merge = (left: number[], right: number[]): number[] => { let result: number[] = []; let li = 0, ri = 0; while (li < left.length && ri < right.length) { if (left[li] < right[ri]) result.push(left[li++]); else result.push(right[ri++]); } return [...result, ...left.slice(li), ...right.slice(ri)]; };",
    "linearSearch": "const linearSearch = (arr: number[], x: number): number => { for (let i = 0; i < arr.length; i++) { if (arr[i] === x) return i; } return -1; };",
    "bubbleSort": "const bubbleSort = (arr: number[]): number[] => { let n = arr.length; for (let i = 0; i < n; i++) { for (let j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { let temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; };",
    "factorialIterative": "const factorialIterative = (n: number): number => { let result = 1; for (let i = 1; i <= n; i++) { result *= i; } return result; };",
    "nthRoot": "const nthRoot = (x: number, n: number): number => Math.pow(x, 1 / n);",
    "logarithm": "const logarithm = (x: number, base: number = 10): number => Math.log(x) / Math.log(base);",
    "exponential": "const exponential = (x: number): number => Math.exp(x);",
    "sin": "const sin = (x: number): number => Math.sin(x);",
    "cos": "const cos = (x: number): number => Math.cos(x);",
    "tan": "const tan = (x: number): number => Math.tan(x);",
    "asin": "const asin = (x: number): number => Math.asin(x);",
    "acos": "const acos = (x: number): number => Math.acos(x);",
    "atan": "const atan = (x: number): number => Math.atan(x);",
    "randomInt": "const randomInt = (min: number, max: number): number => Math.floor(Math.random() * (max - min + 1)) + min;",
    "shuffleArray": "const shuffleArray = (arr: number[]): number[] => { for (let i = arr.length - 1; i > 0; i--) { let j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; };",
    "debounce": "const debounce = (func: Function, delay: number) => { let timerId: NodeJS.Timeout; return (...args: any[]) => { clearTimeout(timerId); timerId = setTimeout(() => func(...args), delay); }; };",
    "throttle": "const throttle = (func: Function, limit: number) => { let lastRan: number, lastFunc: NodeJS.Timeout; return (...args: any[]) => { if (!lastRan) { func(...args); lastRan = Date.now(); } else { clearTimeout(lastFunc); lastFunc = setTimeout(() => { if ((Date.now() - lastRan) >= limit) { func(...args); lastRan = Date.now(); } }, limit - (Date.now() - lastRan)); } }; };",
    "cloneDeep": "const cloneDeep = (obj: any): any => JSON.parse(JSON.stringify(obj));",
    "deepEqual": "const deepEqual = (a: any, b: any): boolean => JSON.stringify(a) === JSON.stringify(b);",
    "flattenArray": "const flattenArray = (arr: any[]): any[] => arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flattenArray(val) : val), []);",
    "uniqueElements": "const uniqueElements = (arr: any[]): any[] => [...new Set(arr)];",
    "intersection": "const intersection = (arr1: any[], arr2: any[]): any[] => arr1.filter(value => arr2.includes(value));"
}
